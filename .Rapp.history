HSIC(A,B,60)
HSIC(A,B,60)
HSIC(A,A,60)
HSIC(A,A,60)
HSIC(A,A,60)
HSIC(B,B,60)
Pval.HSIC(A, B, 10, HSIC(A, B, 10))
dim(A)
dim(B)
K <- A
L <- B
N <- 10
1/(N*(N-1)) * sum(K[upper.tri(K)])
1/(N*(N-1)) * sum(L[upper.tri(L)])
1 / N * (1 + u_x2 * u_y2 - u_x2 - u_y2)
u_x2 <- 1/(N*(N-1)) * sum(K[upper.tri(K)])#
    u_y2 <- 1/(N*(N-1)) * sum(L[upper.tri(L)])#
    E_HSIC <- 1 / N * (1 + u_x2 * u_y2 - u_x2 - u_y2)
E_HSIC
dim(A)
H <- matrix(rep(-1/N), nrow=N, ncol=N)#
    diag(H) <- 1 - 1/N#
    B <- H %*% K %*% H * H %*% L %*% H#
    B <- B * B#
    var_HSIC <- sum(2*(N-4)*(N-5)/(N*(N-1)*(N-2)*(N-3)) * t(rep(1, length=N)) %*% (B-diag(B)))
H
A <- as.matrix(custom.DiffusionMap(t(testdata))$M)#
B <- CatKernel(label, type="one_vs_rest")#
HSIC(A, B, 60)#
HSIC(A, A, 60)#
HSIC(B, B, 60)#
Pval.HSIC(A, B, 60, HSIC(A, B, 60))#
Pval.HSIC(A, A, 60, HSIC(A, A, 60))#
Pval.HSIC(B, B, 60, HSIC(B, B, 60))
4757+583+4824+151
layout(matrix(c(1,2), ncol=2))#
plot(HSICs, Pvals)#
plot(sameHSICs, samePvals)
HSICs#
sameHSICs#
Pvals#
samePvals
HSIC(A, B, 60)#
HSIC(A, A, 60)#
HSIC(B, B, 60)#
Pval.HSIC(A, B, 60, HSIC(A, B, 60))#
Pval.HSIC(A, A, 60, HSIC(A, A, 60))
Pval.HSIC <- function(K, L, N, HSIC){#
    # HSICの期待値#
    u_x2 <- 1/(N*(N-1)) * sum(K[upper.tri(K)])#
    u_y2 <- 1/(N*(N-1)) * sum(L[upper.tri(L)])#
    E_HSIC <- 1 / N * (1 + u_x2 * u_y2 - u_x2 - u_y2)#
#
    # HSICの分散#
    H <- matrix(rep(-1/N), nrow=N, ncol=N)#
    diag(H) <- 1 - 1/N#
    B <- H %*% K %*% H * H %*% L %*% H#
    B <- B * B#
    var_HSIC <- sum(2*(N-4)*(N-5)/(N*(N-1)*(N-2)*(N-3)) * t(rep(1, length=N)) %*% (B-diag(B)))#
#
    if(E_HSIC <= 0){#
        E_HSIC <- 0.0001#
    }#
    if(var_HSIC <= 0){#
        var_HSIC <- 0.0001#
    }#
#
    # Shape parameter（ > 0）#
    Alpha <- E_HSIC^2 / var_HSIC#
    # Scale paramter（ > 0）#
    Beta <- N * var_HSIC / E_HSIC#
    # この値がガンマ分布に従う（ > 0）#
    x <- N * HSIC#
#
    # p値#
    pgamma(x, shape=Alpha, scale=Beta, lower.tail=FALSE)#
}
HSICs <- c()#
Pvals <- c()#
sameHSICs <- c()#
samePvals <- c()#
for(i in 1:100){#
    print(i)#
    A <- as.matrix(custom.DiffusionMap(matrix(rnorm(1000), nrow=10))$M)#
    B <- CatKernel(sample(1:10, replace=TRUE, 10), type="one_vs_rest")#
#
    HSICs[i] <- HSIC(A, B, 10)#
    sameHSICs[i] <- HSIC(A, B, 10)#
    Pvals[i] <- Pval.HSIC(A, B, 10, HSIC(A, B, 10))#
    samePvals[i] <- Pval.HSIC(A, A, 10, HSIC(A, A, 10))#
}#
HSICs#
sameHSICs#
Pvals#
samePvals
mean(K*L)+mean(K)*mean(L)-2*mean(outer(colMeans(K),colMeans(L),"*"))
%in%
1 %in% c(1,2,3)
1 %in% c(2,3)
ifelse
ifelse(is.zero(0), 1, 0)
ifelse(is.nan(NaN), 1, 0)
NaN
ifelse(is.nan(NaN), 1, 0)
ifelse(is.nan(NaN), 0, 0)
ifelse(is.nan(NaN), 0, 1)
ifelse(!is.nan(NaN), 0, 1)
source("http://bioconductor.org/biocLite.R")
library(foreach)
install.packages("foreach")
x <- foreach(i=1:3) %do% sqrt(i)
x
# HSICを利用した特徴量抽出#
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, n.cores=n.cores, algorithm=c("brute", "song"), n.skip=5, threshold=0.01){#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
    #######################################################
    ######################## brute #######################
    #######################################################
    if(algorithm == "brute"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        #️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .cores=n.cores, .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L")) %do% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L, N)#
                # HSICsがNaNなら打ち切り#
                if(is.nan(tmp_HSIC)){#
                    break#
                # HSICsがマイナスなら打ち切り#
                }else if(tmp_HSIC <= 0){#
                    break#
                }else{#
                    # それ以外なら格納#
                    return(tmp_HSIC)#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                }else{#
                    break#
                }#
            }#
        }#
    #######################################################
    #######################################################
    #######################################################
#
    #######################################################
    ######################### song ########################
    #######################################################
    }else if(algorithm == "song"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        # 生き残った遺伝子の場所#
        SurvPosition <- 1:nrow(data)#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > n.skip){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = SurvPosition, .cores=n.cores, .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L")) %do% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L, N)#
                return(tmp_HSIC)#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:n.skip]#
            # 打ち切り#
            if(max(HSICs) - max(tmp_MaxHSICs) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            }else{#
                break#
            }#
        }#
#
    #######################################################
    #######################################################
    #######################################################
    }else{#
        warning("Wrong algorithm!")#
    }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[2:length(HSICs)]#
        )#
}
# 標準正規分布#
CellA <- data.frame(matrix(rnorm(100*20), nrow=100, ncol=20))#
CellB <- data.frame(matrix(rnorm(100*20), nrow=100, ncol=20))#
CellC <- data.frame(matrix(rnorm(100*20), nrow=100, ncol=20))#
#
# DEGを指定（もっと最適な作り方を調べる必要あり）#
CellA[1:10, ] <- CellA[1:10, ] + 10 * matrix(runif(10*20), nrow=10, ncol=20)#
CellB[11:20, ] <- CellB[1:10, ] + 10 * matrix(runif(10*20), nrow=10, ncol=20)#
CellC[21:30, ] <- CellC[1:10, ] + 10 * matrix(runif(10*20), nrow=10, ncol=20)#
#
testdata <- data.frame(CellA, CellB, CellC)#
#
colnames(testdata) <- c(paste0("CellA_", 1:20), paste0("CellB_", 1:20), paste0("CellC_", 1:20))#
rownames(testdata) <- paste0("Gene", 1:nrow(testdata))#
#
# ラベル#
label <- c(rep(1, 20), rep(2, 20), rep(3, 20))
# 教師あり（クラスラベルを与える）#
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, n.cores=4, algorithm="song", n.skip=10, threshold=0.01)
library("doParallel")
registerDoParallel(detectCores())
detectCores()
?foreach
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), n.skip=5, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
    #######################################################
    ######################## brute #######################
    #######################################################
    if(algorithm == "brute"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        #️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L")) %do% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L, N)#
                # HSICsがNaNなら打ち切り#
                if(is.nan(tmp_HSIC)){#
                    break#
                # HSICsがマイナスなら打ち切り#
                }else if(tmp_HSIC <= 0){#
                    break#
                }else{#
                    # それ以外なら格納#
                    return(tmp_HSIC)#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                }else{#
                    break#
                }#
            }#
        }#
    #######################################################
    #######################################################
    #######################################################
#
    #######################################################
    ######################### song ########################
    #######################################################
    }else if(algorithm == "song"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        # 生き残った遺伝子の場所#
        SurvPosition <- 1:nrow(data)#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > n.skip){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = SurvPosition, .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L")) %do% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L, N)#
                return(tmp_HSIC)#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:n.skip]#
            # 打ち切り#
            if(max(HSICs) - max(tmp_MaxHSICs) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            }else{#
                break#
            }#
        }#
#
    #######################################################
    #######################################################
    #######################################################
    }else{#
        warning("Wrong algorithm!")#
    }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[2:length(HSICs)]#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", n.skip=10, threshold=0.01)
# HSICを利用した特徴量抽出#
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), n.skip=5, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
    #######################################################
    ######################## brute #######################
    #######################################################
    if(algorithm == "brute"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        #️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %do% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L, N)#
                # HSICsがNaNなら打ち切り#
                if(is.nan(tmp_HSIC)){#
                    break#
                # HSICsがマイナスなら打ち切り#
                }else if(tmp_HSIC <= 0){#
                    break#
                }else{#
                    # それ以外なら格納#
                    return(tmp_HSIC)#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                }else{#
                    break#
                }#
            }#
        }#
    #######################################################
    #######################################################
    #######################################################
#
    #######################################################
    ######################### song ########################
    #######################################################
    }else if(algorithm == "song"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        # 生き残った遺伝子の場所#
        SurvPosition <- 1:nrow(data)#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > n.skip){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = SurvPosition, .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %do% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L, N)#
                return(tmp_HSIC)#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:n.skip]#
            # 打ち切り#
            if(max(HSICs) - max(tmp_MaxHSICs) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            }else{#
                break#
            }#
        }#
#
    #######################################################
    #######################################################
    #######################################################
    }else{#
        warning("Wrong algorithm!")#
    }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[2:length(HSICs)]#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", n.skip=10, threshold=0.01)
head(result1$DEGs)#
plot(result1$HSICs)
# HSICを利用した特徴量抽出#
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), n.skip=5, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
    #######################################################
    ######################## brute #######################
    #######################################################
    if(algorithm == "brute"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        #️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L, N)#
                # HSICsがNaNなら打ち切り#
                if(is.nan(tmp_HSIC)){#
                    break#
                # HSICsがマイナスなら打ち切り#
                }else if(tmp_HSIC <= 0){#
                    break#
                }else{#
                    # それ以外なら格納#
                    return(tmp_HSIC)#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                }else{#
                    break#
                }#
            }#
        }#
    #######################################################
    #######################################################
    #######################################################
#
    #######################################################
    ######################### song ########################
    #######################################################
    }else if(algorithm == "song"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        # 生き残った遺伝子の場所#
        SurvPosition <- 1:nrow(data)#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > n.skip){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = SurvPosition, .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L, N)#
                return(tmp_HSIC)#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:n.skip]#
            # 打ち切り#
            if(max(HSICs) - max(tmp_MaxHSICs) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            }else{#
                break#
            }#
        }#
#
    #######################################################
    #######################################################
    #######################################################
    }else{#
        warning("Wrong algorithm!")#
    }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[2:length(HSICs)]#
        )#
}
head(result1$DEGs)#
plot(result1$HSICs)
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", n.skip=10, threshold=0.01)
dim(K)[1]
nrow(K)
all
dim(K)
dim(K), dim(L)
c(dim(K), dim(L))
all(c(dim(K), dim(L)), 60)
range(x <- sort(round(stats::rnorm(10) - 1.2, 1)))
x
all(c(dim(K), dim(L)) == 60)
all(c(dim(K), dim(L)), "==")
all.equal
all.equal(c(dim(K), dim(L)))
?all.equal
all.equal(pi, 355/113)
pi
?all
all(c(dim(K), dim(L)) == dim(K)[1])
?DiffusionMap
############################################################
### ヒルベルト-シュミット独立性基準（K行列とL行列の独立性の指標）#####
############################################################
HSIC <- function(K, L, p.value=NULL){#
    if(!all(c(dim(K), dim(L)) == dim(K)[1])){#
        stop("Inappropriate matrices are specified!\nPlease confirm the number of rows and columns.")#
    }#
#
    N <- dim(K)[1]#
    H <- matrix(rep(-1/N), nrow=N, ncol=N)#
    diag(H) <- 1 - 1/N#
    K <- as.matrix(K)#
    L <- as.matrix(L)#
    # The value of HSIC#
    hsic.value <- sum(diag(K %*% H %*% L %*% H)) / (N-1)^2#
#
    # 例外処理1#
    if(hsic.value < 0){#
        hsic.value <- 0#
    }#
#
    # Pvalue of HSIC#
    if(!is.null(p.value)){#
        # HSICの期待値#
        u_x2 <- 1/(N*(N-1)) * sum(K[upper.tri(K)])#
        u_y2 <- 1/(N*(N-1)) * sum(L[upper.tri(L)])#
        E_HSIC <- 1 / N * (1 + u_x2 * u_y2 - u_x2 - u_y2)#
#
        # HSICの分散#
        H <- matrix(rep(-1/N), nrow=N, ncol=N)#
        diag(H) <- 1 - 1/N#
        B <- H %*% K %*% H * H %*% L %*% H#
        B <- B * B#
        var_HSIC <- sum(2*(N-4)*(N-5)/(N*(N-1)*(N-2)*(N-3)) * t(rep(1, length=N)) %*% (B-diag(B)))#
#
        # 例外処理2#
        if(E_HSIC <= 0){#
            E_HSIC <- 0.0001#
        }#
        if(var_HSIC <= 0){#
            var_HSIC <- 0.0001#
        }#
        # Shape parameter（ > 0）#
        Alpha <- E_HSIC^2 / var_HSIC#
        # Scale paramter（ > 0）#
        Beta <- N * var_HSIC / E_HSIC#
        # この値がガンマ分布に従う（ > 0）#
        x <- N * HSIC#
#
        # p値#
        p_HSIC <- pgamma(x, shape=Alpha, scale=Beta, lower.tail=FALSE)#
    }else{#
        p_HSIC <- NA#
    }#
    # return#
    list(HSIC=hsic.value, Pval=p_HSIC)#
}
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), n.skip=5, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
    #######################################################
    ######################## brute #######################
    #######################################################
    if(algorithm == "brute"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        #️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L)[[1]]#
                # HSICsがNaNなら打ち切り#
                if(is.nan(tmp_HSIC)){#
                    break#
                # HSICsがマイナスなら打ち切り#
                }else if(tmp_HSIC <= 0){#
                    break#
                }else{#
                    # それ以外なら格納#
                    return(tmp_HSIC)#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                }else{#
                    break#
                }#
            }#
        }#
    #######################################################
    #######################################################
    #######################################################
#
    #######################################################
    ######################### song ########################
    #######################################################
    }else if(algorithm == "song"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        # 生き残った遺伝子の場所#
        SurvPosition <- 1:nrow(data)#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > n.skip){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = SurvPosition, .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                K <- dif$M#
                # HSICを計算#
                tmp_HSIC <- HSIC(K, L)[[1]]#
                return(tmp_HSIC)#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:n.skip]#
            # 打ち切り#
            if(max(HSICs) - max(tmp_MaxHSICs) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            }else{#
                break#
            }#
        }#
#
    #######################################################
    #######################################################
    #######################################################
    }else{#
        warning("Wrong algorithm!")#
    }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[2:length(HSICs)]#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", n.skip=10, threshold=0.01)
head(result1$DEGs)#
plot(result1$HSICs)
HSICs <- c()#
Pvals <- c()#
sameHSICs <- c()#
samePvals <- c()#
for(i in 1:100){#
    print(i)#
    A <- as.matrix(custom.DiffusionMap(matrix(rnorm(1000), nrow=10))$M)#
    B <- CatKernel(sample(1:10, replace=TRUE, 10), type="one_vs_rest")#
#
    HSICs[i] <- HSIC(A, B)$HSIC#
    sameHSICs[i] <- HSIC(A, B)$HSIC#
    Pvals[i] <- HSIC(A, B, p.value=TRUE)$Pvals#
    samePvals[i] <- HSIC(A, B, p.value=TRUE)$Pvals#
}#
HSICs#
sameHSICs#
Pvals#
samePvals
HSICs
HSIC(A,B)
HSIC(A,B)$HSIC
print(i)#
    A <- as.matrix(custom.DiffusionMap(matrix(rnorm(1000), nrow=10))$M)#
    B <- CatKernel(sample(1:10, replace=TRUE, 10), type="one_vs_rest")#
#
    HSICs[i] <- HSIC(A, B)$HSIC#
    sameHSICs[i] <- HSIC(A, B)$HSIC#
    Pvals[i] <- HSIC(A, B, p.value=TRUE)$Pvals#
    samePvals[i] <- HSIC(A, B, p.value=TRUE)$Pvals
HSIC(A, B, p.value=TRUE)$Pvals
HSIC <- function(K, L, p.value=NULL){#
    if(!all(c(dim(K), dim(L)) == dim(K)[1])){#
        stop("Inappropriate matrices are specified!\nPlease confirm the number of rows and columns.")#
    }#
#
    N <- dim(K)[1]#
    H <- matrix(rep(-1/N), nrow=N, ncol=N)#
    diag(H) <- 1 - 1/N#
    K <- as.matrix(K)#
    L <- as.matrix(L)#
    # The value of HSIC#
    hsic.value <- sum(diag(K %*% H %*% L %*% H)) / (N-1)^2#
#
    # 例外処理1#
    if(hsic.value < 0){#
        hsic.value <- 0#
    }#
#
    # Pvalue of HSIC#
    if(!is.null(p.value)){#
        # HSICの期待値#
        u_x2 <- 1/(N*(N-1)) * sum(K[upper.tri(K)])#
        u_y2 <- 1/(N*(N-1)) * sum(L[upper.tri(L)])#
        E_HSIC <- 1 / N * (1 + u_x2 * u_y2 - u_x2 - u_y2)#
#
        # HSICの分散#
        H <- matrix(rep(-1/N), nrow=N, ncol=N)#
        diag(H) <- 1 - 1/N#
        B <- H %*% K %*% H * H %*% L %*% H#
        B <- B * B#
        var_HSIC <- sum(2*(N-4)*(N-5)/(N*(N-1)*(N-2)*(N-3)) * t(rep(1, length=N)) %*% (B-diag(B)))#
#
        # 例外処理2#
        if(E_HSIC <= 0){#
            E_HSIC <- 0.0001#
        }#
        if(var_HSIC <= 0){#
            var_HSIC <- 0.0001#
        }#
        # Shape parameter（ > 0）#
        Alpha <- E_HSIC^2 / var_HSIC#
        # Scale paramter（ > 0）#
        Beta <- N * var_HSIC / E_HSIC#
        # この値がガンマ分布に従う（ > 0）#
        x <- N * hsic.value#
#
        # p値#
        p_HSIC <- pgamma(x, shape=Alpha, scale=Beta, lower.tail=FALSE)#
    }else{#
        p_HSIC <- NA#
    }#
    # return#
    list(HSIC=hsic.value, Pval=p_HSIC)#
}
HSIC(A, B, p.value=TRUE)$Pvals
HSIC(A, B, p.value=TRUE)
HSIC(A, B, p.value=TRUE
""
HSICs <- c()#
Pvals <- c()#
sameHSICs <- c()#
samePvals <- c()#
for(i in 1:100){#
    print(i)#
    A <- as.matrix(custom.DiffusionMap(matrix(rnorm(1000), nrow=10))$M)#
    B <- CatKernel(sample(1:10, replace=TRUE, 10), type="one_vs_rest")#
#
    HSICs[i] <- HSIC(A, B)$HSIC#
    sameHSICs[i] <- HSIC(A, B)$HSIC#
    Pvals[i] <- HSIC(A, B, p.value=TRUE)$Pval#
    samePvals[i] <- HSIC(A, B, p.value=TRUE)$Pval#
}#
HSICs#
sameHSICs#
Pvals#
samePvals
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), n.skip=5, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
    #######################################################
    ######################## brute #######################
    #######################################################
    if(algorithm == "brute"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        #️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                }else{#
                    break#
                }#
            }#
        }#
    #######################################################
    #######################################################
    #######################################################
#
    #######################################################
    ######################### song ########################
    #######################################################
    }else if(algorithm == "song"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        # 生き残った遺伝子の場所#
        SurvPosition <- 1:nrow(data)#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > n.skip){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = SurvPosition, .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if("try-error" %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:n.skip]#
            # 打ち切り#
            if(max(HSICs) - max(tmp_MaxHSICs) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            }else{#
                break#
            }#
        }#
#
    #######################################################
    #######################################################
    #######################################################
    }else{#
        warning("Wrong algorithm!")#
    }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[2:length(HSICs)]#
            # Pval = ,#
            # ranking = gene_rank#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", n.skip=10, threshold=0.01)#
#
head(result1$DEGs)#
plot(result1$HSICs)
ranking
hoge <- 1:3
hoge
names(hoge) <- paste0("Gene", 1:3)
hoge
hoge$Gene1
hoge["Gene1"]
hoge["Gene1"] <- 2
hoge
names(hoge)
names(hoge)[1]
hoge[names(hoge)[1]]
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), n.skip=5, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
    #######################################################
    ######################## brute #######################
    #######################################################
    if(algorithm == "brute"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        #️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録（次のステップで省く用）#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                    # 削除した遺伝子を登録（最後出力用）#
                    ranking[which(names(tmp_MaxHSIC) == rownames(data))] <- i#
                }else{#
                    break#
                }#
            }#
        }#
    #######################################################
    #######################################################
    #######################################################
#
    #######################################################
    ######################### song ########################
    #######################################################
    }else if(algorithm == "song"){#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # # 全遺伝子のランキング#
        # ranking <- rep(0, length=nrow(data))#
        # names(ranking) <- rownames(data)#
#
        # 生き残った遺伝子の場所#
        SurvPosition <- 1:nrow(data)#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > n.skip){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = SurvPosition, .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if("try-error" %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:n.skip]#
            # 打ち切り#
            if(max(HSICs) - max(tmp_MaxHSICs) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            }else{#
                break#
            }#
        }#
#
    #######################################################
    #######################################################
    #######################################################
    }else{#
        warning("Wrong algorithm!")#
    }#
#
        # 最後に残った遺伝子でp値を算出#
        # ...#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[2:length(HSICs)],#
            # Pval = ,#
            ranking = ranking#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="brute", n.skip=10, threshold=0.01)
result1
data <- testdata
# データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)
ranking
#️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録（次のステップで省く用）#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                    # 削除した遺伝子を登録（最後出力用）#
                    ranking[which(names(tmp_MaxHSIC) == rownames(data))] <- i#
                }else{#
                    break#
                }#
            }#
        }
# 並列化準備#
    registerDoParallel(detectCores())
#️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録（次のステップで省く用）#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                    # 削除した遺伝子を登録（最後出力用）#
                    ranking[which(names(tmp_MaxHSIC) == rownames(data))] <- i#
                }else{#
                    break#
                }#
            }#
        }
gc()
gc()
gc()
gc()
data <- testdata
mode="Supervised"
label=label
type="one_vs_rest"
n.eigs=10
algorithms = "brute"
n.skip = 10
threshold=0.01
# 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }
L
dim(L)
# データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        #️ BAHSICの計算ステップ#
        for(i in 1:nrow(data)){#
            cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            # 今回一番HSICが大きくなった遺伝子#
            if(length(tmp_HSICs) != 0){#
                tmp_MaxHSIC <- tmp_HSICs[which(tmp_HSICs == max(tmp_HSICs))][1]#
            }else{#
                tmp_MaxHSIC <- - 100#
            }#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) < tmp_MaxHSIC){#
                # BAHSICの最大値を格納#
                HSICs[i] <- tmp_MaxHSIC#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
            ###################################################
            }else{#
                # 差がthreshold以下なら続ける#
                if((max(HSICs) - tmp_MaxHSIC) < threshold){#
                    # BAHSICの最大値を格納#
                    HSICs[i] <- tmp_MaxHSIC#
                    # 削除した遺伝子を登録（次のステップで省く用）#
                    RejPosition <- c(RejPosition, which(names(tmp_MaxHSIC) == rownames(data)))#
                    # 削除した遺伝子を登録（最後出力用）#
                    ranking[which(names(tmp_MaxHSIC) == rownames(data))] <- i#
                }else{#
                    break#
                }#
            }#
        }
# データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- rep(0, length=nrow(data))#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)
i <- 1
cat(paste0("======= ", i, " =======\n"))#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)
SurvPosition
length(SurvPosition)
tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }
rank(1:3)
rank(c(1,1,1,3,2))
c(c(), 1:3)
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- c()#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej) #
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ###################################################
            }else{#
                break#
            }#
        }#
#
        # 最後に残った遺伝子でp値を算出（Pval用）#
        # ...#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[2:length(HSICs)]#
            # Pval = ,#
            # ranking = ranking#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", per.rej=10, threshold=0.01)
dim(data)
mode
label
tpe
type
n.eigs
alrogithm
algorithm
algorithm="song"
per.rej=10
threshold
# 並列化準備#
    registerDoParallel(detectCores())
############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }
dim(l)
dim(L)
# データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- c()#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)
ranking
length(SurvPosition) > 5
#️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))
ls()
SurvPosition
custom.DiffusionMap
n.eigs
HSIC
N
# 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }
names(tmp_HSICs) <- rownames(data)[SurvPosition]
if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej) #
            }else{#
                stop("algorithm parameter is wrong!")#
            }
NoRej
N
if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100) #
            }else{#
                stop("algorithm parameter is wrong!")#
            }
NoRej
# HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ###################################################
            }else{#
                break#
            }
max(HSICs)
HSICs <- 0
# HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ###################################################
            }else{#
                break#
            }
# 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]
# HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ###################################################
            }else{#
                break#
            }
max(HSICs)
max(tmp_MaxHSIC)
HSICs
RejPosition
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100) #
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ###################################################
            }else{#
                break#
            }#
        }#
#
        # 最後に残った遺伝子でp値を算出（Pval用）#
        # ...#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[2:length(HSICs)]#
            # Pval = ,#
            # ranking = ranking#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", per.rej=10, threshold=0.01)
head(result1)
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    #######################################################
#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        #️ BAHSICの計算ステップ#
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100) #
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ###################################################
            }else{#
                break#
            }#
        }#
#
        # 最後に残った遺伝子でp値を算出（Pval用）#
        # ...#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = HSICs[names(tmp_HSICs)]#
            # Pval = ,#
            # ranking = ranking#
        )#
}
head(result1)
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", per.rej=10, threshold=0.01)
result1
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="brute", per.rej=10, threshold=0.01)
library("tcltk")
result1
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    ############ ラベル側のグラム行列（終わり）##################
#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        ##️############### BAHSICの計算ステップ #################
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100)#
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ########### 各ステップでの最後の処理（終わり）###########
            }else{#
                break#
            }#
        }#
        ##️############ BAHSICの計算ステップ（終わり） ##############
        # 最後に残った遺伝子でp値を算出（Pval用）#
        # ...#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = tmp_HSICs#
            # Pval = ,#
            # ranking = ranking#
        )#
}
result1
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="brute", per.rej=10, threshold=0.01)
result1
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    ############ ラベル側のグラム行列（終わり）##################
#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        ##️############### BAHSICの計算ステップ #################
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100)#
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ########### 各ステップでの最後の処理（終わり）###########
            }else{#
                break#
            }#
        }#
        ##️############ BAHSICの計算ステップ（終わり） ##############
        # 最後に残った遺伝子でp値を算出（Pval用）#
        pval_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "N", "data", "L"), .combine = "c") %dopar% {#
            # データ側のグラム行列#
            dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
            if ('try-error' %in% class(dif)){#
                return(0)#
            }else{#
                K <- dif$M#
                # HSICのp値を計算#
                HSIC(K, L, p.value=TRUE)$Pval#
            }#
        }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = tmp_HSICs,#
            Pvals = pval_HSICs#
            # ranking = ranking#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="brute", per.rej=10, threshold=0.01)
result1
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    ############ ラベル側のグラム行列（終わり）##################
#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        ##️############### BAHSICの計算ステップ #################
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100)#
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ########### 各ステップでの最後の処理（終わり）###########
            }else{#
                break#
            }#
        }#
        ##️############ BAHSICの計算ステップ（終わり） ##############
        # 最後に残った遺伝子でp値を算出（Pval用）#
        pval_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L"), .combine = "c") %dopar% {#
            # データ側のグラム行列#
            dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
            if ('try-error' %in% class(dif)){#
                return(0)#
            }else{#
                K <- dif$M#
                # HSICのp値を計算#
                HSIC(K, L, p.value=TRUE)$Pval#
            }#
        }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = tmp_HSICs,#
            Pvals = pval_HSICs#
            # ranking = ranking#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", per.rej=10, threshold=0.01)
result1
HSICs
rank(HSICs)
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    ############ ラベル側のグラム行列（終わり）##################
#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        ##️############### BAHSICの計算ステップ #################
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100)#
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ########### 各ステップでの最後の処理（終わり）###########
            }else{#
                break#
            }#
        }#
        ##️############ BAHSICの計算ステップ（終わり） ##############
        # 最後に残った遺伝子でp値を算出（Pval用）#
        pval_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L"), .combine = "c") %dopar% {#
            # データ側のグラム行列#
            dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
            if ('try-error' %in% class(dif)){#
                return(0)#
            }else{#
                K <- dif$M#
                # HSICのp値を計算#
                HSIC(K, L, p.value=TRUE)$Pval#
            }#
        }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = tmp_HSICs,#
            Pvals = pval_HSICs,#
            ranking = rank(HSICs[2:length(HSICs)])#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", per.rej=10, threshold=0.01)
result1
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    ############ ラベル側のグラム行列（終わり）##################
#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        ##️############### BAHSICの計算ステップ #################
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100)#
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ########### 各ステップでの最後の処理（終わり）###########
            }else{#
                break#
            }#
        }#
        ##️############ BAHSICの計算ステップ（終わり） ##############
        # 最後に残った遺伝子でp値を算出（Pval用）#
        pval_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L"), .combine = "c") %dopar% {#
            # データ側のグラム行列#
            dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs))#
            if ('try-error' %in% class(dif)){#
                return(0)#
            }else{#
                K <- dif$M#
                # HSICのp値を計算#
                HSIC(K, L, p.value=TRUE)$Pval#
            }#
        }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = tmp_HSICs,#
            Pvals = pval_HSICs,#
            rej.order = rank(HSICs[setdiff(2:length(HSICs), which(is.na(HSICs)))])#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", per.rej=10, threshold=0.01)
result1
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="brute", per.rej=10, threshold=0.01)
result1
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    ############ ラベル側のグラム行列（終わり）##################
#
        # データ数#
        N <- ncol(data)#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
        # 全遺伝子のランキング#
        ranking <- rep(0, length=nrow(data))#
        names(ranking) <- rownames(data)#
#
        ##️############### BAHSICの計算ステップ #################
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 共通で使うsigmaの計算#
            sigma =  try(destiny::optimal.sigma(find.sigmas(as.ExpressionSet(as.data.frame(t(data[SurvPosition,]))), verbose = FALSE)), silent = TRUE)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L", "sigma"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs, sigma=sigma))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100)#
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ########### 各ステップでの最後の処理（終わり）###########
            }else{#
                break#
            }#
        }#
        ##️############ BAHSICの計算ステップ（終わり） ##############
        # 最後に残った遺伝子でp値を算出（Pval用）#
        pval_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L", "sigma"), .combine = "c") %dopar% {#
            # データ側のグラム行列#
            dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs, sigma=sigma))#
            if ('try-error' %in% class(dif)){#
                return(0)#
            }else{#
                K <- dif$M#
                # HSICのp値を計算#
                HSIC(K, L, p.value=TRUE)$Pval#
            }#
        }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = tmp_HSICs,#
            Pvals = pval_HSICs,#
            rej.order = rank(HSICs[setdiff(2:length(HSICs), which(is.na(HSICs)))])#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="brute", per.rej=10, threshold=0.01)
result1
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    ############ ラベル側のグラム行列（終わり）##################
#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        ##️############### BAHSICの計算ステップ #################
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 共通で使うsigmaの計算#
            sigma =  try(destiny::optimal.sigma(find.sigmas(as.ExpressionSet(as.data.frame(t(data[SurvPosition,]))), verbose = FALSE)), silent = TRUE)#
#
            # 生き残り内での繰り返し#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L", "sigma"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs, sigma=sigma))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100)#
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ########### 各ステップでの最後の処理（終わり）###########
            }else{#
                break#
            }#
        }#
        ##️############ BAHSICの計算ステップ（終わり） ##############
#
        # 最後に残った遺伝子でp値を算出（Pval用）#
        pval_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L", "sigma"), .combine = "c") %dopar% {#
            # データ側のグラム行列#
            dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs, sigma=sigma))#
            if ('try-error' %in% class(dif)){#
                return(0)#
            }else{#
                K <- dif$M#
                # HSICのp値を計算#
                HSIC(K, L, p.value=TRUE)$Pval#
            }#
        }#
#
        # 結果を出力#
        list(#
            DEGs = names(tmp_HSICs),#
            HSICs = tmp_HSICs,#
            Pvals = pval_HSICs,#
            Rej.order = rank(HSICs[setdiff(2:length(HSICs), which(is.na(HSICs)))])#
        )#
}
result1 <- FUCHIKOMA(data=testdata, mode="Supervised", label=label, type="one_vs_rest", n.eigs=10, algorithm="song", per.rej=10, threshold=0.01)
result1
plot(result1$HSICs)
############################################################
############# FUCHIKOMA : HSICを利用した特徴量抽出 ############
############################################################
FUCHIKOMA <- function(data, mode=c("Supervised", "Unsupervised"), Comp=FALSE, label=FALSE, type=FALSE, n.eigs=10, algorithm=c("brute", "song"), per.rej=10, threshold=0.01){#
#
    # 並列化準備#
    registerDoParallel(detectCores())#
#
    ############ ラベル側のグラム行列（一回のみ） ###############
    if((mode == "Supervised") && (is.vector(label))){#
        L <- CatKernel(label, type=type)#
    }else if(mode == "Unsupervised"){#
        if(is.vector(Comp)){#
            EigenVecs <- custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data))), n.eigs=n.eigs)$eigenvectors[, Comp]#
            L <- EigenVecs %*% t(EigenVecs)#
        }else{#
            warning("Specify Comp!")#
        }#
    }else{#
        warning("Wrong mode!")#
    }#
    ############ ラベル側のグラム行列（終わり）##################
#
        # HSIC値の格納先#
        HSICs <- 0#
        # 削除した遺伝子の場所#
        RejPosition <- c()#
#
        ##️############### BAHSICの計算ステップ #################
        while(length(SurvPosition) > 5){#
            #️ このステップで見る遺伝子（生き残り）#
            SurvPosition <- setdiff(1:nrow(data), RejPosition)#
            cat(paste0("### No. of remaining gene is ", length(SurvPosition), " ###\n"))#
#
            # 共通で使うsigmaの計算#
            sigma =  try(destiny::optimal.sigma(find.sigmas(as.ExpressionSet(as.data.frame(t(data[SurvPosition,]))), verbose = FALSE)), silent = TRUE)#
#
            # 生き残り遺伝子内でのHSIC計算#
            tmp_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L", "sigma"), .combine = "c") %dopar% {#
                # データ側のグラム行列#
                dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs, sigma=sigma))#
                if ('try-error' %in% class(dif)){#
                    return(0)#
                }else{#
                    K <- dif$M#
                    # HSICを計算#
                    tmp_HSIC <- HSIC(K, L)$HSIC#
                    return(ifelse(is.nan(tmp_HSIC), 0, tmp_HSIC))#
                }#
            }#
            names(tmp_HSICs) <- rownames(data)[SurvPosition]#
#
            ############### 各ステップでの最後の処理 ##############
            if(algorithm == "brute"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- 1#
            }else if(algorithm == "song"){#
                # 今回一番HSICが大きくなった遺伝子#
                NoRej <- round(N * per.rej / 100)#
            }else{#
                stop("algorithm parameter is wrong!")#
            }#
#
            # 今回HSICが最大な上位n個の遺伝子#
            tmp_MaxHSICs <- rev(sort(tmp_HSICs))[1:NoRej]#
#
            # HSICsがこれまでのHSICsの最大値よりも小さくなったら打ち切り#
            if(max(HSICs) - max(tmp_MaxHSIC) < threshold){#
                # BAHSICの最大値を格納#
                HSICs <- c(HSICs, tmp_MaxHSICs)#
                # 削除した遺伝子を登録#
                RejPosition <- c(RejPosition, unlist(sapply(names(tmp_MaxHSICs), function(x){which(x == rownames(data))})))#
            ########### 各ステップでの最後の処理（終わり）###########
            }else{#
                break#
            }#
        }#
        ##️############ BAHSICの計算ステップ（終わり） ##############
#
        # 最後に残った遺伝子でp値を算出（Pval用）#
        pval_HSICs <- foreach(j = 1:length(SurvPosition), .export=c("SurvPosition", "custom.DiffusionMap", "n.eigs", "HSIC", "data", "L", "sigma"), .combine = "c") %dopar% {#
            # データ側のグラム行列#
            dif <- try(custom.DiffusionMap(as.ExpressionSet(as.data.frame(t(data[SurvPosition[setdiff(1:length(SurvPosition), j)],]))), n.eigs=n.eigs, sigma=sigma))#
            if ('try-error' %in% class(dif)){#
                return(0)#
            }else{#
                K <- dif$M#
                # HSICのp値を計算#
                HSIC(K, L, p.value=TRUE)$Pval#
            }#
        }#
#
        # 結果を出力#
        list(#
            DEGs.HSICs = names(tmp_HSICs),#
            DEGs.Pvals = pval_HSICs,#
            All.HSICs = HSICs[setdiff(2:length(HSICs), which(is.na(HSICs)))],#
            Rej.order = rank(HSICs[setdiff(2:length(HSICs), which(is.na(HSICs)))])#
        )#
}
setwd("elwood/Dev/FUCHIKOMA/")
source("demo.R")
HSICs
result1$HSICs
result1$All.HSICs
which(max(result1$All.HSICs))
which(max(result1$All.HSICs) == result1$All.HSICs)
result1
source("demo.R")
source("demo.R")
result1
length(result1$All.HSICs)
length(result1$Rej.order)
length(result1$DEGs.HSICs)
rank(result1$HSICs)
rank(result1$All.HSICs)
setdiff(result1$HSICs, result1$DEGs)
setdiff(result1$HSICs, result1$DEGs.HSICs)
setdiff(result1$All.HSICs, result1$DEGs.HSICs)
result1$DEGs.HSICs
result1$All.HSICs
?setdiff
source("demo.R")
result1
source("demo.R")
source("createPackage.R")
